#!/usr/bin/env python3
# get_modifiable_code.py - Obtient le VRAI code source modifiable

import re
import zlib
import marshal
import sys
import os
import subprocess

def get_clean_source():
    """D√©chiffre et retourne le code source PROPRE"""
    
    print("üîì D√âCHIFFREMENT POUR MODIFICATION")
    print("=" * 50)
    
    # 1. Lire l'original
    with open('task.py', 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()
    
    # 2. Extraire payload et salt
    payload_match = re.search(r"payload_data\s*=\s*'([a-f0-9]+)'", content)
    salt_match = re.search(r"config_salt\s*=\s*'([a-f0-9]+)'", content)
    
    if not payload_match or not salt_match:
        print("‚ùå Variables non trouv√©es")
        return None
    
    payload_hex = payload_match.group(1)
    salt_hex = salt_match.group(1)
    
    print(f"‚úÖ Payload: {len(payload_hex)//2} bytes")
    print(f"‚úÖ Salt: {len(salt_hex)//2} bytes")
    
    # 3. D√©chiffrement
    salt = bytes.fromhex(salt_hex)
    payload = bytes.fromhex(payload_hex)
    
    # XOR
    decrypted = bytearray()
    for i, byte in enumerate(payload):
        decrypted.append(byte ^ salt[i % len(salt)])
    
    # Zlib + Marshal
    try:
        decompressed = zlib.decompress(bytes(decrypted))
        code_obj = marshal.loads(decompressed)
    except:
        code_obj = marshal.loads(bytes(decrypted))
    
    print("‚úÖ Code objet d√©chiffr√©")
    
    # 4. D√âCOMPILER en source propre
    print("\nüîß D√©compilation en source Python...")
    
    # Essayer decompyle3
    try:
        import decompyle3
        import io
        
        output = io.StringIO()
        from decompyle3 import decompile
        
        try:
            decompile(sys.version_info[:2], code_obj, out=output)
            source_code = output.getvalue()
            print("‚úÖ D√©compilation r√©ussie avec decompyle3")
        except Exception as e:
            print(f"‚ùå decompyle3 √©chou√©: {e}")
            raise
    
    except ImportError:
        print("‚ùå decompyle3 non install√©")
        print("Installation: pip install decompyle3")
        
        # Sauvegarder l'objet pour d√©compilation externe
        with open('temp_codeobj.bin', 'wb') as f:
            marshal.dump(code_obj, f)
        
        print("‚úÖ Objet sauvegard√©: temp_codeobj.bin")
        print("D√©compilez avec: python -m decompyle3 temp_codeobj.bin")
        return None
    
    # 5. NETTOYER le code source
    print("\nüßπ Nettoyage du code source...")
    
    # Corriger les probl√®mes courants
    clean_source = source_code
    
    # Remplacer les imports probl√©matiques
    clean_source = clean_source.replace("from colorama import *", 
                                       "from colorama import Fore, Style, Back, init")
    
    # Ajouter un shebang
    if not clean_source.startswith('#!/'):
        clean_source = "#!/usr/bin/env python3\n" + clean_source
    
    # Ajouter un en-t√™te
    header = f'''"""
Code d√©chiffr√© et modifiable
Original: task.py (obfusqu√©)
D√©chiffr√© le: {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Python: {sys.version}
"""

'''
    clean_source = header + clean_source
    
    return clean_source

def save_modifiable_file(source_code, filename="task_modifiable.py"):
    """Sauvegarde le code modifiable"""
    
    print(f"\nüíæ Sauvegarde: {filename}")
    
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(source_code)
    
    # Compter les lignes
    line_count = len(source_code.split('\n'))
    print(f"üìÑ {line_count} lignes de code")
    
    # V√©rifier la syntaxe
    print("‚úì V√©rification syntaxique...")
    try:
        compile(source_code, filename, 'exec')
        print("‚úÖ Syntaxe Python valide")
    except SyntaxError as e:
        print(f"‚ö†Ô∏è  Probl√®me syntaxique: {e}")
        # Corriger automatiquement
        source_code = fix_syntax_errors(source_code)
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(source_code)
        print("‚úÖ Corrig√© automatiquement")
    
    return filename

def fix_syntax_errors(source_code):
    """Corrige les erreurs de syntaxe courantes"""
    
    corrections = [
        # Probl√®me: 'print' sans parenth√®ses (Python 2 vs 3)
        (r'print\s+([^\n]+)(?=\n)', r'print(\1)'),
        
        # Probl√®me: except Exception, e: ‚Üí except Exception as e:
        (r'except\s+([^,]+),\s*([^:]+):', r'except \1 as \2:'),
        
        # Probl√®me: backticks (Python 2)
        (r'`([^`]+)`', r'repr(\1)'),
    ]
    
    for pattern, replacement in corrections:
        source_code = re.sub(pattern, replacement, source_code)
    
    return source_code

def create_editor_script(modifiable_file):
    """Cr√©e un script pour √©diter facilement"""
    
    editor_script = f'''#!/usr/bin/env python3
# edit_{modifiable_file}.py - √âditeur pour le code d√©chiffr√©

import os
import sys

def main():
    print("üõ†Ô∏è  √âDITEUR POUR {modifiable_file}")
    print("=" * 50)
    
    if not os.path.exists("{modifiable_file}"):
        print(f"‚ùå {modifiable_file} non trouv√©")
        return
    
    print(f"üìÅ Fichier: {modifiable_file}")
    print(f"üìè Taille: {os.path.getsize(modifiable_file)} bytes")
    
    print("\\nüìã Options:")
    print("1. Voir le code")
    print("2. √âditer avec nano")
    print("3. √âditer avec vim")
    print("4. Ex√©cuter le code")
    print("5. Quitter")
    
    choice = input("\\nChoix (1-5): ").strip()
    
    if choice == '1':
        # Afficher les 100 premi√®res lignes
        os.system(f"head -100 {modifiable_file}")
        
    elif choice == '2':
        os.system(f"nano {modifiable_file}")
        
    elif choice == '3':
        os.system(f"vim {modifiable_file}")
        
    elif choice == '4':
        print("\\nüöÄ Ex√©cution...")
        os.system(f"python {modifiable_file}")
        
    elif choice == '5':
        print("üëã Au revoir!")
        
    else:
        print("‚ùå Choix invalide")

if __name__ == "__main__":
    main()
'''
    
    script_name = f"edit_{modifiable_file.replace('.py', '')}.py"
    with open(script_name, 'w') as f:
        f.write(editor_script)
    
    os.chmod(script_name, 0o755)
    print(f"‚úÖ Script d'√©dition: {script_name}")
    
    return script_name

def main():
    """Fonction principale"""
    
    print("üõ†Ô∏è  CR√âATION DE CODE MODIFIABLE")
    print("=" * 50)
    
    # 1. Obtenir le code source propre
    source_code = get_clean_source()
    if not source_code:
        print("\n‚ùå Impossible d'obtenir le code source")
        return
    
    # 2. Sauvegarder
    modifiable_file = save_modifiable_file(source_code, "task_clean.py")
    
    # 3. Cr√©er un script d'√©dition
    editor_script = create_editor_script(modifiable_file)
    
    # 4. Afficher les instructions
    print(f"\nüéâ CODE MODIFIABLE PR√äT !")
    print("=" * 50)
    print(f"üìÅ Fichier principal: {modifiable_file}")
    print(f"üõ†Ô∏è  Script d'√©dition: {editor_script}")
    
    print(f"\nüìã COMMANDES UTILES:")
    print(f"  # √âditer le code")
    print(f"  nano {modifiable_file}")
    print(f"  python {editor_script}")
    
    print(f"\n  # Voir la structure")
    print(f"  grep -n 'def \\|class \\|import ' {modifiable_file}")
    
    print(f"\n  # Compter les lignes")
    print(f"  wc -l {modifiable_file}")
    
    print(f"\n  # Ex√©cuter")
    print(f"  python {modifiable_file}")
    
    # 5. Montrer un aper√ßu
    print(f"\nüëÅÔ∏è  APER√áU DU CODE:")
    print("-" * 40)
    with open(modifiable_file, 'r') as f:
        for i in range(20):
            line = f.readline()
            if not line:
                break
            print(f"{i+1:3}: {line.rstrip()}")
    print("...")

if __name__ == "__main__":
    main()
