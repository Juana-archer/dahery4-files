#!/usr/bin/env python3
# complete_extract.py - Tout en un

import re
import zlib
import marshal
import sys
import os

print("ðŸ”„ EXTRACTION COMPLÃˆTE DU CODE")
print("=" * 50)

# 1. LIRE task.py
with open('task.py', 'r', encoding='utf-8', errors='ignore') as f:
    content = f.read()

print("ðŸ“¦ Extraction des variables...")

# 2. TROUVER payload_data COMPLÃˆTE (mÃ©thode robuste)
payload_match = None
salt_match = None

# Chercher payload_data (peut Ãªtre sur plusieurs lignes)
lines = content.split('\n')
current_line = ''
for line in lines:
    if 'payload_data' in line:
        current_line = line
        # Si la ligne se termine par ... continuer
        while current_line.count("'") % 2 == 1:  # Quotes non fermÃ©es
            # Chercher la suite
            idx = lines.index(line) + 1
            if idx < len(lines):
                current_line += lines[idx]
                line = lines[idx]
            else:
                break
        payload_match = current_line
        break

# Extraire la valeur hex
if payload_match:
    import re
    hex_match = re.search(r"'([a-f0-9]+)'", payload_match)
    if hex_match:
        payload_hex = hex_match.group(1)
        print(f"âœ… Payload: {len(payload_hex)//2} bytes")
    else:
        print("âŒ Format payload incorrect")
        exit(1)
else:
    print("âŒ payload_data non trouvÃ©e")
    exit(1)

# 3. TROUVER config_salt
salt_match = re.search(r"config_salt\s*=\s*'([a-f0-9]+)'", content)
if salt_match:
    salt_hex = salt_match.group(1)
    print(f"âœ… Salt: {len(salt_hex)//2} bytes")
else:
    print("âŒ config_salt non trouvÃ©e")
    exit(1)

# 4. DÃ‰CHIFFRER
print("\nðŸ”“ DÃ©chiffrement...")
salt = bytes.fromhex(salt_hex)
payload = bytes.fromhex(payload_hex)

# XOR
decrypted = bytearray()
for i, byte in enumerate(payload):
    decrypted.append(byte ^ salt[i % len(salt)])

# Zlib + Marshal
try:
    decompressed = zlib.decompress(bytes(decrypted))
    code_obj = marshal.loads(decompressed)
    print(f"âœ… Avec zlib: {len(decompressed)} bytes")
except zlib.error:
    code_obj = marshal.loads(bytes(decrypted))
    print(f"âœ… Sans zlib: {len(decrypted)} bytes")

print("ðŸŽ¯ Code objet chargÃ©")

# 5. DÃ‰COMPILER
print("\nðŸ”§ DÃ©compilation...")

source_code = None
method_used = ""

# Essayer decompyle3 d'abord
try:
    from decompyle3 import decompile
    import io
    
    print("  MÃ©thode: decompyle3...")
    output = io.StringIO()
    
    # Essayer diffÃ©rentes versions Python
    for version in [(3, 11), (3, 10), (3, 9), (3, 8), (3, 7)]:
        try:
            output = io.StringIO()
            decompile(version, code_obj, out=output)
            source_code = output.getvalue()
            method_used = f"decompyle3 Python {version[0]}.{version[1]}"
            print(f"  âœ… RÃ©ussi avec Python {version[0]}.{version[1]}")
            break
        except:
            continue
    
except ImportError as e:
    print(f"  âŒ decompyle3: {e}")

# Si decompyle3 Ã©choue, essayer uncompyle6
if not source_code:
    try:
        import uncompyle6
        import io
        
        print("  MÃ©thode: uncompyle6...")
        output = io.StringIO()
        uncompyle6.deparse_code2str(code_obj, output)
        source_code = output.getvalue()
        method_used = "uncompyle6"
        print("  âœ… RÃ©ussi")
        
    except ImportError as e:
        print(f"  âŒ uncompyle6: {e}")

# Si toujours rien, utiliser le bytecode
if not source_code:
    print("  âŒ DÃ©compilateurs Ã©chouÃ©s, utilisation bytecode")
    import dis
    import io
    
    output = io.StringIO()
    dis.dis(code_obj, file=output)
    source_code = f"# BYTECODE SEULEMENT\n# Installez: pip install decompyle3 uncompyle6\n'''\n{output.getvalue()}\n'''"
    method_used = "bytecode"

# 6. SAUVEGARDER
output_file = "task_MODIFIABLE.py"
print(f"\nðŸ’¾ Sauvegarde: {output_file}")

with open(output_file, 'w', encoding='utf-8') as f:
    f.write("#!/usr/bin/env python3\n")
    f.write('"""\n')
    f.write('CODE MODIFIABLE - DÃ‰CHIFFRÃ‰\n')
    f.write(f'Original: task.py (obfusquÃ©)\n')
    f.write(f'MÃ©thode: {method_used}\n')
    f.write(f'DÃ©chiffrÃ© le: {__import__("datetime").datetime.now().strftime("%Y-%m-%d %H:%M:%S")}\n')
    f.write('"""\n\n')
    
    # Ajouter les variables originales pour rÃ©fÃ©rence
    f.write("# Variables originales du fichier chiffrÃ©:\n")
    f.write(f"# config_salt = '{salt_hex}'\n")
    f.write(f"# payload_data = '{payload_hex[:100]}...'  # {len(payload_hex)//2} bytes\n")
    f.write("\n" + "="*60 + "\n")
    f.write("# CODE DÃ‰CHIFFRÃ‰ ET MODIFIABLE\n")
    f.write("="*60 + "\n\n")
    
    f.write(source_code)

# Compter les lignes
with open(output_file, 'r') as f:
    lines = f.readlines()
    line_count = len(lines)

print(f"âœ… Fichier crÃ©Ã©: {output_file}")
print(f"ðŸ“„ {line_count} lignes, {os.path.getsize(output_file)} bytes")

# 7. VÃ‰RIFIER
print("\nðŸ” VÃ©rification...")
try:
    # Compiler pour vÃ©rifier la syntaxe
    with open(output_file, 'r') as f:
        test_code = f.read()
    compile(test_code, output_file, 'exec')
    print("âœ… Syntaxe Python valide")
    
    # AperÃ§u
    print("\nðŸ‘ï¸  APERÃ‡U (premiÃ¨res 30 lignes):")
    print("-" * 40)
    for i in range(min(30, line_count)):
        print(f"{i+1:3}: {lines[i].rstrip()}")
        
except SyntaxError as e:
    print(f"âš ï¸  ProblÃ¨me syntaxique: {e}")
    print("Le fichier est peut-Ãªtre en bytecode seulement")
    
    # Afficher le dÃ©but diffÃ©remment
    print("\nðŸ“‹ DÃ©but du fichier:")
    with open(output_file, 'r') as f:
        for i in range(10):
            line = f.readline()
            print(line.rstrip())

# 8. CRÃ‰ER UN SCRIPT POUR EXÃ‰CUTER
runner_script = f'''#!/usr/bin/env python3
# run_{output_file} - ExÃ©cute le code dÃ©chiffrÃ©

import sys
import os

print("ðŸš€ EXÃ‰CUTION DU CODE DÃ‰CHIFFRÃ‰")
print("=" * 50)

# VÃ©rifier les dÃ©pendances
try:
    import colorama
    from colorama import Fore, Style
    colorama.init(autoreset=True)
    print("âœ… colorama importÃ©")
except ImportError:
    print("âš ï¸  colorama non installÃ©: pip install colorama")
    # CrÃ©er des fausses constantes
    class FakeFore:
        RED = GREEN = YELLOW = BLUE = MAGENTA = CYAN = WHITE = RESET = ''
    class FakeStyle:
        RESET_ALL = ''
    Fore = FakeFore()
    Style = FakeStyle()

try:
    import requests
    print("âœ… requests importÃ©")
except ImportError:
    print("âš ï¸  requests non installÃ©: pip install requests")

try:
    import asyncio
    print("âœ… asyncio importÃ©")
except ImportError:
    print("âš ï¸  asyncio non disponible")

print("\\nðŸŽ® ExÃ©cution de {output_file}...")
print("-" * 50)

# ExÃ©cuter
try:
    with open('{output_file}', 'r') as f:
        code = f.read()
    exec(code)
except Exception as e:
    print(f"âŒ Erreur: {{e}}")
    import traceback
    traceback.print_exc()
'''

with open(f'run_{output_file}', 'w') as f:
    f.write(runner_script)

os.chmod(f'run_{output_file}', 0o755)
print(f"\nðŸŽ¯ Script d'exÃ©cution: run_{output_file}")

print(f"\n{'='*50}")
print("ðŸŽ‰ EXTRACTION TERMINÃ‰E !")
print(f"{'='*50}")
print(f"ðŸ“ Fichier modifiable: {output_file}")
print(f"ðŸš€ Pour exÃ©cuter: python {output_file}")
print(f"   ou: ./run_{output_file}")
print(f"âœï¸  Pour Ã©diter: nano {output_file}")
